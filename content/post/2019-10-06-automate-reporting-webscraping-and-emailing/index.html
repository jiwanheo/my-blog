---
title: 'Automate Reporting: Webscraping and Emailing'
author: Jiwan Heo
date: '2019-10-06'
tags:
  - webscraping
---

<p>Hey, just wanted to share how you can automate the reporting process of pulling information from a website and emailing it to people or to yourself. You can even schedule this to run everyday at a certain time, which is neat.</p>
<p>The process itself is pretty simple. You first figure out how the website presents the information you’re looking for, scrape it, and edit it. The workflow I’m suggesting in this post is as follows:</p>
<ol style="list-style-type: decimal">
<li><a href="#scrape">Scrape</a></li>
<li><a href="#email">Email</a></li>
<li><a href="#scheduler">Run this every morning</a></li>
</ol>
<div id="scrape" class="section level2">
<h2>Scrape</h2>
<div class="figure"><span id="fig:unnamed-chunk-1"></span>
<img src="lets_scrape.png" alt="Marketwatch.com front page" width="683" />
<p class="caption">
Figure 1: Marketwatch.com front page
</p>
</div>
<p>We’re gonna pull from marketwatch.com, the good old Dow, S&amp;P and 4 other familiar metrics at the top left corner.</p>
<p>As usual, I’m using tidyverse to clean up data. The new packages I’m using today are <code>rvest</code>, for webscraping, <code>mailR</code> for emailing.</p>
<pre class="r"><code>library(tidyverse)
library(rvest)</code></pre>
<p>If we go back to chrome and press <code>F12</code> on PC, or <code>Crtl</code> <code>Option</code> <code>J</code> on Mac, it’ll take you to developers mode.</p>
<div class="figure"><span id="fig:unnamed-chunk-3"></span>
<img src="important_info.png" alt="Important features" width="683" />
<p class="caption">
Figure 2: Important features
</p>
</div>
<p>Make sure you’re on the “Elements” tab. Here, you want to find the HTML element of the things you want to pull. You can either do this by clicking the cursor Icon at the top, and clicking the object, or unnest your way down the HTML code on the right side.</p>
<p>Now to scrape this table, we can use <code>.</code> to call the classes of the <code>table</code> element (3 of them “table”, “table–primary”, “align–right”). Kinda confusing how we’re calling a <code>table</code> element that has the class of “table”, but yea. It’s super useful how you can call multiple classes of objects to narrow down the search.</p>
<pre class="r"><code>webpage &lt;- read_html(&quot;https://www.marketwatch.com/&quot;)

webpage %&gt;% 
  html_node(&quot;table.table.table--primary.align--right&quot;) </code></pre>
<pre><code>## {html_node}
## &lt;table class=&quot;table table--primary align--right&quot;&gt;
## [1] &lt;tbody class=&quot;row-hover markets__group&quot;&gt;\n&lt;tr onclick=&quot;this.querySel ...</code></pre>
<p>Taking it a step further, we’re going to pull a <code>child</code> element of the table, <code>tbody</code>, which has the classes of <code>row-hover</code>, and <code>markets__group</code>. As you can imagine, <code>tbody</code> is short for “table body”</p>
<pre class="r"><code>markets &lt;- webpage %&gt;% 
  html_node(&quot;.table.table--primary.align--right &gt; 
            tbody.row-hover.markets__group&quot;) </code></pre>
<div class="figure"><span id="fig:unnamed-chunk-6"></span>
<img src="table_content.png" alt="Construction of the HTML table" width="683" />
<p class="caption">
Figure 3: Construction of the HTML table
</p>
</div>
<p>If we look at the structure of the <code>tbody</code>, there are 6 indexes that we’re interested in, each one of them being <code>tr</code>, short for table row. (Dow, S&amp;P 500, …) Then each row is further divided into <code>table__cell</code>, <code>table__cell symbol</code>, <code>table__cell price</code>, and so on. We’re going to just pull symbol and price. Now, let’s pull all texts from this table.</p>
<pre class="r"><code>markets %&gt;% 
  html_text() </code></pre>
<pre><code>## [1] &quot;\n                                \n                            Dow\n                            \n                                26,573.72\n                            \n                                372.68\n                            \n                                    1.42%\n                            \n                                \n                                \n                        \n                                \n                            S&amp;P 500\n                            \n                                2,952.01\n                            \n                                41.38\n                            \n                                    1.42%\n                            \n                                \n                                \n                        \n                                \n                            Nasdaq\n                            \n                                7,982.47\n                            \n                                110.21\n                            \n                                    1.40%\n                            \n                                \n                                \n                        \n                                \n                            GlobalDow\n                            \n                                2,963.39\n                            \n                                20.61\n                            \n                                    0.70%\n                            \n                                \n                                \n                        \n                                \n                            Gold\n                            \n                                1,514.00\n                            \n                                1.10\n                            \n                                    0.07%\n                            \n                                \n                                \n                        \n                                \n                            Oil\n                            \n                                52.65\n                            \n                                -0.16\n                            \n                                    -0.30%\n                            \n                                \n                                \n                        &quot;</code></pre>
<p>This is too messy, so I’m going to use <code>str_squish</code>, which removes obviously unnecessary empty spaces including new lines. Also, I’m going to remove the commas, just to make it easier for myself to do regex later to pull these information.</p>
<pre class="r"><code>text_markets &lt;- markets %&gt;% 
  html_text() %&gt;% 
  str_squish() %&gt;% 
  str_remove(&quot;\\,&quot;)

text_markets</code></pre>
<pre><code>## [1] &quot;Dow 26573.72 372.68 1.42% S&amp;P 500 2,952.01 41.38 1.42% Nasdaq 7,982.47 110.21 1.40% GlobalDow 2,963.39 20.61 0.70% Gold 1,514.00 1.10 0.07% Oil 52.65 -0.16 -0.30%&quot;</code></pre>
<p>If you read my <a href="https://jiwanheo.rbind.io/blog/2019-07-28-nba-twitter-sentiment-2019-offseason/">first post</a>, I used the <code>tidytext</code> package to do some sentiment analysis. I’m going to use it again to do some text wrangling. First, I need to unnest the sentence, which means I’m going to break up every single word into a row in a data frame. One inconveniet thing that I couldn’t get around was the fact that the <code>unnest_tokens</code> function doesn’t take anything other than a <code>data.frame</code> object as input, so I use the <code>tibble</code> function first.</p>
<pre class="r"><code>library(tidytext)

tidy_text_df &lt;- tibble(text = text_markets) %&gt;% 
  unnest_tokens(word, text)

tidy_text_df</code></pre>
<pre><code>## # A tibble: 26 x 1
##    word    
##    &lt;chr&gt;   
##  1 dow     
##  2 26573.72
##  3 372.68  
##  4 1.42    
##  5 s       
##  6 p       
##  7 500     
##  8 2,952.01
##  9 41.38   
## 10 1.42    
## # ... with 16 more rows</code></pre>
<p>Brutal manual labour to deal with “S” “P” “500”.</p>
<pre class="r"><code>tidy_text_df &lt;- tidy_text_df[-c(6, 7),]
tidy_text_df[5,] &lt;- &quot;S&amp;P 500&quot;</code></pre>
<p>This is a little regex to filter out those words that start with a digit, AKA everything excluding our markets. This returns a list of True and False.</p>
<pre class="r"><code>char_test &lt;- str_detect(tidy_text_df$word, &quot;^\\d&quot;)
char_test</code></pre>
<pre><code>##  [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
## [12]  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE
## [23]  TRUE  TRUE</code></pre>
<p>Here’s a neat trick. <code>!</code> means “not”, so it now assigns True, to the market names. I can use this list of booleans to index a dataframe. (in my case, rows)</p>
<pre class="r"><code>exchanges &lt;- tidy_text_df[!char_test,]
exchanges</code></pre>
<pre><code>## # A tibble: 6 x 1
##   word     
##   &lt;chr&gt;    
## 1 dow      
## 2 S&amp;P 500  
## 3 nasdaq   
## 4 globaldow
## 5 gold     
## 6 oil</code></pre>
<p>Now, I couldn’t think of a better way to filter for prices (closing value) of the exchanges. So I inefficiently ran a loop to see detect the market names from <code>exchanges</code>, and saved the next row as the corresponding price.</p>
<pre class="r"><code>prices &lt;- integer()

# Adding the pre-existing vector with the new element every time
for (i in 1:length(tidy_text_df$word)) {
  if (tidy_text_df[i,]$word %in% as.vector(exchanges$word)) {
    prices &lt;- c(prices, tidy_text_df[i +1,]$word)
  }
}

prices</code></pre>
<pre><code>## [1] &quot;26573.72&quot; &quot;2,952.01&quot; &quot;7,982.47&quot; &quot;2,963.39&quot; &quot;1,514.00&quot; &quot;52.65&quot;</code></pre>
<p>Putting it all together, we have a data frame of market names and closing prices.</p>
<pre class="r"><code>final_df &lt;- data.frame(exchange = exchanges, price = prices)

final_df</code></pre>
<pre><code>##        word    price
## 1       dow 26573.72
## 2   S&amp;P 500 2,952.01
## 3    nasdaq 7,982.47
## 4 globaldow 2,963.39
## 5      gold 1,514.00
## 6       oil    52.65</code></pre>
</div>
<div id="email" class="section level2">
<h2>Email</h2>
<p>OK, so we succesfully gathered and prepared the information we wanted. Let’s look at how we can email using the <code>mailR</code> package.</p>
<p>Warning! This package was built as a wrapper around Apache Commons Email, which runs on Java Mail API. So you’re going to have to have the same version of Java, as your R (x86 or x64). I had some trouble configuring this, but eventually found a solution after searching on stackoverflow. You have to set the JAVA_HOME Path, which basically tells your computer where to look for Java. You can do this in R with</p>
<pre class="r"><code># Sys.setenv(JAVA_HOME=&#39;C:\\Program Files\\Java\\jdk1.8.0_221\\jre&#39;)</code></pre>
<p>Notice how it looks for Java in “Program Files” folder, the 64-bit version of Java, which is the same version that my R runs in.</p>
<p>We can go ahead with the <code>mailR</code> package now. You’ll need to download the <code>rJava</code> package as well, which I spent more time than I’d like to admit trying to make it work. Recall the <code>final_df</code> we created earlier. It turns out that I can’t straight up write a data.frame object in the email. To get around this, I just wrote a csv and attached it to the email.</p>
<pre class="r"><code># install.packages(&quot;rJava)
# install.packages(&quot;mailR&quot;)

library(rJava)
library(mailR)</code></pre>
<pre class="r"><code>sender &lt;- &quot;jiwanheo123@gmail.com&quot;
recipients &lt;- c(&quot;jiwanheo123@gmail.com&quot;, &quot;jheo3565@gmail.com&quot;)
attachment &lt;- &quot;C:/Users/jiwan/Desktop/rProjects/blog_jiwanheo/content/blog/2019-10-06-automate-reporting-webscraping-and-emailing/market_watch_csv.csv&quot;
market_watch_csv &lt;- write_csv(final_df, attachment)

# send.mail(from = sender,
#           to = recipients,
#           subject = &quot;Marketwatch Data Pull&quot;,
#           body = &quot;This is the latest marketwatch pull&quot;,
#           smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465,
#                       user.name = &quot;jiwanheo123@gmail.com&quot;,
#                       passwd = &quot;None of your concerns yo&quot;, ssl = TRUE),
#           attach.files = attachment,
#           authenticate = TRUE,
#           send = TRUE)</code></pre>
<p>The results look like this.</p>
<div class="figure"><span id="fig:unnamed-chunk-18"></span>
<img src="email1.png" alt="Downloadable csv file" width="683" />
<p class="caption">
Figure 4: Downloadable csv file
</p>
</div>
<p>If that didn’t work, you may have to give <a href="https://myaccount.google.com/lesssecureapps?pli=1">less secupre app access</a> on Google.</p>
</div>
<div id="scheduler" class="section level2">
<h2>Scheduler</h2>
<p>Finally, if you write the above into a nice R script, you can have your computer run the script automatically, with either the built-in task scheduler, or the <code>taskscheduleR</code> in R.</p>
<pre class="r"><code># library(taskscheduleR)
# myscript &lt;- system.file(&quot;extdata&quot;, &quot;scrape_and_email.R&quot;, package = &quot;taskscheduleR&quot;)

# taskscheduler_create(taskname = &quot;Marketwatch_data_scrape&quot;, rscript = myscript, 
#                     schedule = &quot;DAILY&quot;, starttime = &quot;09:00&quot;, 
#                     startdate = format(Sys.Date()+1, &quot;%d/%m/%Y&quot;))</code></pre>
<p>I didn’t save this process in a single script, so I commented out the scheduler step, but I think you get the idea. The above will run what we just covered so far, every morning at 9 a.m. starting tomorrow.</p>
<p>There you have it guys, hope you learned something, and maybe you can implement this in your professional life.</p>
</div>
